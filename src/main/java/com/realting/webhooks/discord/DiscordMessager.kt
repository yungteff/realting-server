package com.realting.webhooks.discord

import ca.momoperes.canarywebhooks.DiscordMessage
import ca.momoperes.canarywebhooks.WebhookClientBuilder
import ca.momoperes.canarywebhooks.embed.DiscordEmbed
import com.realting.util.Misc
import org.json.JSONObject
import java.awt.Color
import java.lang.Exception
import java.net.URI

object DiscordMessager : JSONObject() {
    @JvmField
    var active = false
    private const val testhook = ""
    private const val announcementhook = ""
    private const val staffhook = ""
    private const val ingamehook = ""
    private const val debughook = ""
    private const val yellhook = ""
    private const val pmhook = ""
    private const val chathook = ""
    private const val clanhook = ""

    @JvmStatic
    fun test(msg: String?) {
        var msg = msg
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = testhook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("NecroticRSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.YELLOW) // The color of the embed. You can leave this at null for no color
                .withDescription("This message was generated by the server.") // The description of the embed object
                .build() // Build the embed element
            if (msg == null || msg === "") {
                msg =
                    "```hi this is a server test``` @everyone @crimson @crimson#2406 test \"quotes\" \nnewline :fire: :100: :ironman:"
            }
            val message = DiscordMessage.Builder(Misc.stripIngameFormat(msg)) // The content of the message
                .withEmbed(embed) // Add our embed object
                .withUsername("Kandarin Bot") // Override the username of the bot
                .build() // Build the message
            client.sendPayload(message)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun sendAnnouncement(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = announcementhook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder().withTitle("Kandarin - RSPS") // The title of the embed element
                .withURL("http://kandarin.org/") // The URL of the embed element
                .withColor(Color.GREEN) // The color of the embed. You can leave this at null for no color
                .withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val message = DiscordMessage.Builder(Misc.stripIngameFormat(msg)) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Announcement Bot") // Override the username of the bot
                .build() // Build the message
            client.sendPayload(message)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendStaffMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = staffhook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("Necrotic - RSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.ORANGE) // The color of the embed. You can leave this at null for no color
                .withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val message = DiscordMessage.Builder(Misc.stripIngameFormat(msg)) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Staff Bot") // Override the username of the bot
                .build() // Build the message
            client.sendPayload(message)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendChatMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = chathook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("Necrotic - RSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.YELLOW) // The color of the embed. You can leave this at null for no color
                //.withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val msgToSend = Misc.stripIngameFormat(msg)
            val message = DiscordMessage.Builder(msgToSend) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Chat Bot") // Override the username of the bot
                .build() // Build the message
            if (msgToSend.equals(":information_source:!", ignoreCase = true)) {
                sendDebugMessage("Bad message from sendChatMessage, \n$msgToSend")
            } else {
                client.sendPayload(message)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendClanMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = clanhook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("Necrotic - RSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.GREEN) // The color of the embed. You can leave this at null for no color
                //.withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val msgToSend = Misc.stripIngameFormat(msg)
            val message = DiscordMessage.Builder(msgToSend) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Clan Bot") // Override the username of the bot
                .build() // Build the message
            if (msgToSend.equals(":information_source:!", ignoreCase = true)) {
                sendDebugMessage("Bad message from sendClanMessage, \n$msgToSend")
            } else {
                client.sendPayload(message)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendPrivateMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = pmhook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("Necrotic - RSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.MAGENTA) // The color of the embed. You can leave this at null for no color
                //.withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val msgToSend = Misc.stripIngameFormat(msg)
            val message = DiscordMessage.Builder(msgToSend) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Privacy Bot") // Override the username of the bot
                .build() // Build the message
            if (msgToSend.equals(":information_source:!", ignoreCase = true)) {
                sendDebugMessage("Bad message from sendPrivateMessage, \n$msgToSend")
            } else {
                client.sendPayload(message)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendInGameMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = ingamehook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("Necrotic - RSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.BLUE) // The color of the embed. You can leave this at null for no color
                .withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val msgToSend = Misc.stripIngameFormat(msg)
            val message = DiscordMessage.Builder(msgToSend) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("In-Game Bot") // Override the username of the bot
                .build() // Build the message
            if (msgToSend.equals(":information_source:!", ignoreCase = true)) {
                sendDebugMessage("Bad message from sendInGameMessage, \n$msgToSend")
            } else {
                client.sendPayload(message)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendDebugMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = debughook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder().withTitle("Kandarin - RSPS") // The title of the embed element
                .withURL("http://Kandarin.org/") // The URL of the embed element
                .withColor(Color.MAGENTA) // The color of the embed. You can leave this at null for no color
                .withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element

            //DiscordMessage message = new DiscordMessage.Builder(msg) 
            val message = DiscordMessage.Builder(Misc.stripIngameFormat(msg)) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Debug Bot") // Override the username of the bot
                .build() // Build the message
            client.sendPayload(message)
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    @JvmStatic
    fun sendYellMessage(msg: String?) {
        try {
            if (Misc.checkForOwner() || !active) {
                return
            }
            val webhook = yellhook
            val client = WebhookClientBuilder().withURI(URI(webhook)).build() // Create the webhook client
            val embed = DiscordEmbed.Builder() //.withTitle("Necrotic - RSPS") // The title of the embed element
                //.withURL("http://necrotic.org/") // The URL of the embed element
                .withColor(Color.WHITE) // The color of the embed. You can leave this at null for no color
                .withDescription("Remember, you can mute any specific channel by clicking the bell in the top right of Discord.") // The description of the embed object
                .build() // Build the embed element
            val msgToSend = Misc.stripIngameFormat(msg)
            val message = DiscordMessage.Builder(msgToSend) // The content of the message
                //.withEmbed(embed) // Add our embed object
                .withUsername("Yell Bot") // Override the username of the bot
                .build() // Build the message
            if (msgToSend.equals(":information_source:!", ignoreCase = true)) {
                sendDebugMessage("Bad message from sendYellMessage, \n$msgToSend")
            } else {
                client.sendPayload(message)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    } /*System.out.println("test");
	URL url = new URL("https://discordapp.com/api/webhooks/264884075129470976/NvJNe980SYO3DKjOPxoJRx9ew6Y9T6jYxteG_HOZ9zPNewCUj2vskZZMsjtzBiiOn75J");
	HttpURLConnection conn = (HttpURLConnection) url.openConnection();
	conn.setDoOutput(true);
	conn.setRequestMethod("POST");
	conn.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
	conn.setRequestProperty("Accept", "application/json; charset=UTF-8");
	
	JSONObject discord = new JSONObject();
	
	//ARGS: username, content, avatar_url, tts
	discord.put("username", "test");
	discord.put("content", "@everyone hallo it is me a fRIENDD!@@#!@#!@#!@#!@#!@#!@#!@#!@#");
	
	//discord.put("avatar_url", "http://i.imgur.com/4Da0jRZ.png");
	//discord.put("tts", false);
	
	OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());
	discord.write(wr);
	wr.flush();
	
	StringBuilder sb = new StringBuilder();  
	int HttpResult = conn.getResponseCode(); 
	if (HttpResult == HttpURLConnection.HTTP_OK) {
		System.out.println("HTTP = OK");
	    BufferedReader br = new BufferedReader(
	            new InputStreamReader(conn.getInputStream(), "utf-8"));
	    String line = null;  
	    while ((line = br.readLine()) != null) {  
	        sb.append(line + "\n");  
	    }
	    br.close();
	    System.out.println("" + sb.toString());  
	} else {
		System.out.println("HTTP = NOT OK");
	    System.out.println(conn.getResponseMessage());  
	}  */
}